<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Tiny-QR WebRTC (minimal fields — best-effort)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui,Arial;max-width:900px;margin:18px auto;padding:12px}
  .card{border:1px solid #ddd;padding:12px;border-radius:8px;margin-bottom:12px;background:#fafafa}
  #qrArea{text-align:center}
  #cam{width:100%;max-width:360px;border-radius:8px;display:none}
  #log{height:180px;overflow:auto;background:#fff;padding:8px;border:1px solid #eee}
  button{padding:8px 12px;margin:6px}
  .small{font-size:13px;color:#555}
</style>
</head>
<body>
<h2>Tiny-QR WebRTC — Minimal fields (best-effort)</h2>
<p class="small">Host: click <strong>Start host</strong>. Client: select Client and click <strong>Start</strong>. The code attempts to keep the QR token &lt;100 chars by sending only ICE ufrag/pwd, candidate, and DTLS fingerprint. A fallback to compressed full SDP is included.</p>

<div class="card">
  <label>Role:</label>
  <select id="role"><option value="host">Host</option><option value="client">Client</option></select>
  <button id="startBtn">Start</button>
  <button id="stopBtn" disabled>Stop</button>
  <div class="small">Note: camera permission required on client/host for automatic scanning.</div>
</div>

<div class="card">
  <div id="qrArea"></div>
  <canvas id="qrCanvas" style="display:none"></canvas>
  <video id="cam" autoplay playsinline></video>
  <div id="qrHint" class="small"></div>
</div>

<div class="card">
  <label>Log</label>
  <div id="log"></div>
</div>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>

<script>
/*
Overview:
- Host: createOffer() -> extract minimal fields -> compress -> show QR
- Client: scan -> decompress -> build minimal offer SDP template -> setRemoteDescription(offer) -> createAnswer() -> extract minimal fields -> compress -> show QR
- Host: scan answer QR -> decompress -> reconstruct full answer SDP template -> setRemoteDescription(answer)
- Fallback: if minimal exchange fails, we fall back to sending compressed full SDP ("FULL:" prefix)
*/

// ---------- Helpers ----------
const logEl = document.getElementById('log');
function log(s){ logEl.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${s}</div>`; logEl.scrollTop = logEl.scrollHeight; }

function utf8ToBase64(str){
  return btoa(unescape(encodeURIComponent(str)));
}
function base64ToUtf8(b64){
  return decodeURIComponent(escape(atob(b64)));
}

function compressToToken(obj){
  try{
    const json = JSON.stringify(obj);
    const bytes = new TextEncoder().encode(json);
    const def = pako.deflate(bytes);
    // convert to binary string for btoa
    let bin = '';
    for(let i=0;i<def.length;i++) bin += String.fromCharCode(def[i]);
    const b64 = btoa(bin);
    return 'T:'+b64; // tiny token
  }catch(e){ console.error(e); return null; }
}

function decompressFromToken(token){
  try{
    if(!token) return null;
    if(token.startsWith('T:')){
      const b64 = token.slice(2);
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for(let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i);
      const dec = pako.inflate(arr);
      const json = new TextDecoder().decode(dec);
      return JSON.parse(json);
    }
    if(token.startsWith('FULL:')){ // fallback full compressed SDP
      const b64 = token.slice(5);
      const bin = atob(b64);
      return { full_sdp: base64ToUtf8(bin) };
    }
    return null;
  }catch(e){ console.error(e); return null; }
}

// ---------- QR helpers ----------
function showQR(text, hint){
  const area = document.getElementById('qrArea');
  area.innerHTML = '';
  try {
    QRCode.toCanvas(text, {width:300}, (err, canvas) => {
      if(err){ area.textContent = text; console.error(err); }
      else area.appendChild(canvas);
    });
  } catch(e){
    area.textContent = text;
  }
  document.getElementById('qrHint').textContent = hint||'';
}

const cam = document.getElementById('cam');
let camStream = null;
let scanning = false;
const scanCanvas = document.createElement('canvas');
const scanCtx = scanCanvas.getContext('2d');

async function startCamera(){
  if(camStream) return camStream;
  camStream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
  cam.srcObject = camStream;
  cam.style.display = 'block';
  return camStream;
}
function stopCamera(){
  if(camStream){ camStream.getTracks().forEach(t=>t.stop()); camStream=null; }
  cam.style.display='none';
}

function startScan(onDetected){
  scanning = true;
  startCamera().then(()=> requestAnimationFrame(loop));
  function loop(){
    if(!scanning) return;
    if(cam.videoWidth>0 && cam.videoHeight>0){
      scanCanvas.width = cam.videoWidth; scanCanvas.height = cam.videoHeight;
      scanCtx.drawImage(cam,0,0,scanCanvas.width,scanCanvas.height);
      const img = scanCtx.getImageData(0,0,scanCanvas.width,scanCanvas.height);
      const code = jsQR(img.data, img.width, img.height, { inversionAttempts: "attemptBoth" });
      if(code && code.data){
        scanning = false;
        onDetected(code.data);
        return;
      }
    }
    requestAnimationFrame(loop);
  }
}

function stopScan(){ scanning=false; stopCamera(); }

// ---------- SDP parsing helpers ----------
function parseSDPForMinimalParts(sdp){
  // extract a=ice-ufrag, a=ice-pwd, first a=candidate line (we take the entire candidate), and a=fingerprint line
  const lines = sdp.split(/\r\n|\n/);
  const result = { ufrag:null, pwd:null, candidate:null, fingerprint:null };
  for(const l of lines){
    if(!result.ufrag && l.startsWith('a=ice-ufrag:')) result.ufrag = l.slice(12).trim();
    if(!result.pwd && l.startsWith('a=ice-pwd:')) result.pwd = l.slice(10).trim();
    if(!result.fingerprint && l.startsWith('a=fingerprint:')) result.fingerprint = l.slice(14).trim(); // "sha-256 <hex>"
    if(!result.candidate && l.startsWith('a=candidate:')) result.candidate = l.slice(12).trim();
    if(result.ufrag && result.pwd && result.candidate && result.fingerprint) break;
  }
  return result;
}

// Build a minimal offer SDP template given remote fields (we build something browsers accept)
function buildOfferSDPTemplate({ ufrag, pwd, candidate, fingerprint }){
  // This template is intentionally small — we use very basic v= and m= lines for datachannel only.
  // NOTE: This is a best-effort template. Some browsers may reject malformed SDPs.
  const lines = [
    'v=0',
    'o=- 0 0 IN IP4 127.0.0.1',
    's=-',
    't=0 0',
    'a=group:BUNDLE 0',
    'a=msid-semantic: WMS',
    'm=application 9 DTLS/SCTP 5000',
    'c=IN IP4 0.0.0.0',
    'a=mid:0',
    'a=sctpmap:5000 webrtc-datachannel 1024',
    `a=ice-ufrag:${ufrag}`,
    `a=ice-pwd:${pwd}`,
    `a=fingerprint:${fingerprint}`,
    `a=candidate:${candidate}`,
    'a=end-of-candidates'
  ];
  return lines.join('\r\n') + '\r\n';
}

// build an answer SDP template given local answer's minimal info (if needed)
function buildAnswerSDPTemplate({ ufrag, pwd, candidate, fingerprint }){
  // Very similar to offer template, but for answer we usually include actual port for m=application; using 9 is fine for ICE.
  const lines = [
    'v=0',
    'o=- 0 0 IN IP4 127.0.0.1',
    's=-',
    't=0 0',
    'a=group:BUNDLE 0',
    'a=msid-semantic: WMS',
    'm=application 9 DTLS/SCTP 5000',
    'c=IN IP4 0.0.0.0',
    'a=mid:0',
    'a=sctpmap:5000 webrtc-datachannel 1024',
    `a=ice-ufrag:${ufrag}`,
    `a=ice-pwd:${pwd}`,
    `a=fingerprint:${fingerprint}`,
    `a=candidate:${candidate}`,
    'a=end-of-candidates'
  ];
  return lines.join('\r\n') + '\r\n';
}

// ---------- Core flows ----------
let pc = null;
let dc = null;
let role = 'host';
let localChannelReady = false;

const roleEl = document.getElementById('role');
document.getElementById('startBtn').onclick = start;
document.getElementById('stopBtn').onclick = stop;

function stop(){
  document.getElementById('startBtn').disabled = false;
  document.getElementById('stopBtn').disabled = true;
  stopScan();
  stopCamera();
  if(pc){ try{ pc.close(); }catch{} pc=null; }
  log('Stopped.');
}

async function start(){
  role = roleEl.value;
  document.getElementById('startBtn').disabled = true;
  document.getElementById('stopBtn').disabled = false;
  log('Start role: ' + role);
  if(role === 'host') await hostFlow();
  else await clientFlow();
}

// utilities for ICE gathering completion
function waitIceComplete(pcRef, timeout=5000){
  return new Promise(resolve=>{
    if(!pcRef) return resolve();
    if(pcRef.iceGatheringState === 'complete') return resolve();
    function handler(){ if(pcRef.iceGatheringState === 'complete'){ pcRef.removeEventListener('icegatheringstatechange', handler); resolve(); } }
    pcRef.addEventListener('icegatheringstatechange', handler);
    setTimeout(()=>resolve(), timeout);
  });
}

// HOST FLOW
async function hostFlow(){
  // create pc and datachannel
  pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
  dc = pc.createDataChannel('tiny');
  dc.onopen = ()=>{ log('Host: data channel open'); localChannelReady=true; };
  dc.onmessage = ev => log('Host: received -> ' + ev.data);
  pc.oniceconnectionstatechange = ()=> log('Host ICE: ' + pc.iceConnectionState);

  // create offer
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  log('Host: created local offer.');

  // wait ICE candidates be gathered (so candidate lines exist)
  await waitIceComplete(pc, 4000);

  const localSDP = pc.localDescription.sdp || offer.sdp;
  const parts = parseSDPForMinimalParts(localSDP);
  // if we failed to parse fingerprint or candidate, fallback to full SDP compressed
  const minimalObj = {u:parts.ufrag, p:parts.pwd, c:parts.candidate, f:parts.fingerprint};

  let token = compressToToken(minimalObj);
  // if token too long or missing key parts, fallback to compressed full SDP
  if(!token || token.length > 95 || !parts.ufrag || !parts.pwd || !parts.candidate || !parts.fingerprint){
    log('Host: minimal token not possible or too long; falling back to compressed full SDP.');
    token = 'FULL:' + btoa(utf8ToBase64(localSDP));
  } else {
    log('Host: showing tiny token (length ' + token.length + ') — try to keep <100 chars.');
  }

  showQR(token, 'Host: Have client scan this QR (offer).');

  // after showing offer, host auto-starts camera to scan answer QR
  document.getElementById('qrHint').textContent = 'Host: waiting to scan client Answer QR...';
  try{
    await startCamera();
    startScan(async (qrtext)=>{
      stopScan();
      log('Host: scanned answer token (len ' + qrtext.length + ')');
      const decoded = decompressFromToken(qrtext);
      if(!decoded){ log('Host: failed to decode answer token'); return; }
      if(decoded.full_sdp){
        // fallback: full answer SDP provided
        try{
          await pc.setRemoteDescription({type:'answer', sdp: decoded.full_sdp});
          log('Host: applied full answer SDP (fallback).');
        }catch(e){ log('Host: failed to apply full answer SDP: ' + e); }
        return;
      }
      // decoded should contain minimal parts: u/p/c/f
      const answerMin = decoded;
      if(!answerMin.u || !answerMin.p || !answerMin.c || !answerMin.f){
        log('Host: answer token missing fields; try full SDP fallback.');
        return;
      }
      // reconstruct a minimal answer SDP and set as remote
      const answerSDP = buildAnswerSDPTemplate({ufrag:answerMin.u, pwd:answerMin.p, candidate:answerMin.c, fingerprint:answerMin.f});
      try{
        await pc.setRemoteDescription({type:'answer', sdp: answerSDP});
        log('Host: minimal answer applied. Connection may establish if DTLS/ICE matches.');
      }catch(e){
        log('Host: applying minimal answer failed: ' + e + ' — consider fallback.');
      }
    });
  }catch(e){ log('Host camera error: ' + e); }
}

// CLIENT FLOW
async function clientFlow(){
  // client scans host's token
  document.getElementById('qrHint').textContent = 'Client: point camera to Host QR (offer)';
  try{
    await startCamera();
    startScan(async (qrtext)=>{
      stopScan();
      log('Client: scanned token (len ' + qrtext.length + ')');
      const decoded = decompressFromToken(qrtext);
      if(!decoded){ log('Client: failed to decode token'); return; }
      if(decoded.full_sdp){
        // Host sent full offer — quick path
        const fullOffer = decoded.full_sdp;
        log('Client: applying full offer (fallback).');
        pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
        pc.ondatachannel = ev => { dc = ev.channel; dc.onmessage = e=>log('Client recv: '+e.data); dc.onopen=()=>log('Client: DC open');};
        await pc.setRemoteDescription({type:'offer', sdp:fullOffer});
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await waitIceComplete(pc,4000);
        // send compressed full answer back
        const localSDP = pc.localDescription.sdp;
        const packed = 'FULL:' + btoa(utf8ToBase64(localSDP));
        showQR(packed, 'Client: show this QR (full-answer fallback) to Host');
        log('Client: displayed full answer QR (fallback).');
        return;
      }

      // Minimal path: Host sent minimal u/p/c/f
      const hostMin = decoded;
      if(!hostMin.u || !hostMin.p || !hostMin.c || !hostMin.f){
        log('Client: minimal token missing fields — abort.');
        return;
      }
      log('Client: minimal offer fields received.');

      // Build a local offer SDP (reconstructed) that includes host's candidate/ufrag/pwd/fingerprint
      // We'll create a new RTCPeerConnection and then setRemoteDescription with that constructed offer,
      // then createAnswer() to produce the proper answer (with client's fingerprint and ICE).
      try{
        const offerSDP = buildOfferSDPTemplate({ufrag:hostMin.u, pwd:hostMin.p, candidate:hostMin.c, fingerprint:hostMin.f});
        pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
        pc.oniceconnectionstatechange = ()=> log('Client ICE: ' + pc.iceConnectionState);
        pc.ondatachannel = ev => { dc = ev.channel; dc.onmessage = e=>log('Client recv: '+e.data); dc.onopen=()=>log('Client: DC open'); };

        // set remote (the host's offer built from their minimal pieces)
        await pc.setRemoteDescription({type:'offer', sdp:offerSDP});
        log('Client: applied reconstructed offer; creating answer...');
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await waitIceComplete(pc,4000);

        // extract minimal parts from local answer to send back to host
        const localSDP = pc.localDescription.sdp;
        const parts = parseSDPForMinimalParts(localSDP);
        const ansMin = { u: parts.ufrag, p: parts.pwd, c: parts.candidate, f: parts.fingerprint };

        let token = compressToToken(ansMin);
        if(!token || token.length > 95 || !ansMin.u || !ansMin.p || !ansMin.c || !ansMin.f){
          // fallback to compressed full answer
          log('Client: minimal answer not feasible or too long; falling back to compressed full answer.');
          token = 'FULL:' + btoa(utf8ToBase64(localSDP));
        } else {
          log('Client: showing tiny answer token (len ' + token.length + ').');
        }
        showQR(token, 'Client: show this QR to Host (answer).');

      }catch(e){
        log('Client error during minimal flow: ' + e + ' — falling back to full SDP flow.');

        // fallback: do full-offer path: create pc, set remote using full? (can't — we don't have full). Instead instruct user to use fallback full via Host re-sending full.
        showQR('ERROR: fallback required', 'Client: minimal flow failed. Ask Host to use full-SDP fallback.');
      }
    });
  }catch(e){ log('Client camera error: ' + e); }
}

</script>
</body>
</html>
