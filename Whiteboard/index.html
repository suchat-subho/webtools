<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>P2P Whiteboard ‚Äî Host ‚Üí Clients (Single file)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
/* ========== Styles (kept from prior) ========== */
:root { --left-w: 150px; --toolbar-h: 40px; }
body { margin:0; font-family:Arial, sans-serif; background:#111; color:#fff; overflow:hidden; }
.toolbar { background:#222; height:var(--toolbar-h); display:flex; align-items:center; padding:0 12px; gap:12px; border-bottom:1px solid #444; }
.toolbar h1 { font-size:16px; margin:0; }
.connect-indicator { margin-left:auto; padding:6px 10px; border-radius:6px; color:#fff; border:0; }
.connect-indicator.disconnected { background:#880000; }
.connect-indicator.connected { background:#008800; }

/* left pane */
.leftpane { position:absolute; top:var(--toolbar-h); left:0; width:var(--left-w); bottom:0; background:#1e1e1e; padding:10px; box-sizing:border-box; border-right:2px solid #333; overflow:auto; }
.leftpane button,input,select { width:100%; margin:6px 0; padding:6px; border-radius:6px; border:0; background:#333; color:#fff; cursor:pointer; box-sizing:border-box; }
.leftpane input[type="range"]{ background:transparent; }
.leftpane hr{ border:0; border-top:1px solid #333; margin:8px 0; }
.smalltxt{ color:#aaa; font-size:12px; margin-top:6px; }

/* page tabs, canvas wrap */
.page-tabs { position:absolute; top:var(--toolbar-h); left:calc(var(--left-w) + 11px); right:0; height:28px; background:#222; display:flex; align-items:center; gap:6px; padding:4px; box-sizing:border-box; border-bottom:2px solid #333; overflow:auto; }
.page-tabs button{ background:#333; color:#fff; border:0; padding:4px 8px; border-radius:6px 6px 0 0; cursor:pointer; }
.page-tabs button.active{ background:#555; border-bottom:2px solid #111; }

.canvas-wrap{ position:absolute; top:calc(var(--toolbar-h) + 32px); left:calc(var(--left-w) + 11px); right:0; bottom:0; background:#000; display:flex; align-items:center; justify-content:center; }
#canvas{ width:98%; height:94%; border:4px solid #fff; display:block; touch-action:none; background:#000; }

/* palettes */
.color-table,.bg-table { display:grid; grid-template-columns:repeat(4,24px); gap:6px; margin:6px 0; }
.color-table div,.bg-table div { width:24px; height:24px; border-radius:50%; border:1px solid #666; cursor:pointer; }

/* modal */
.modal { display:none; position:fixed; z-index:999; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.7); }
.modal-content { background:#1e1e1e; color:white; margin:4% auto; padding:16px; border-radius:8px; width:92%; max-width:980px; max-height:86vh; overflow:auto; box-sizing:border-box; }
.modal .close { float:right; font-size:20px; cursor:pointer; color:#f55; border:none; background:transparent; }
.side-by-side { display:flex; gap:12px; align-items:flex-start; }
.section { flex:1; background:#222; padding:10px; border-radius:8px; box-sizing:border-box; }
textarea{ width:100%; height:80px; background:#111; color:#fff; border:1px solid #333; padding:6px; border-radius:6px; resize:vertical; box-sizing:border-box; }

/* misc */
.hidden{ display:none; }
.small { font-size:12px; color:#ccc; }
button.icon { padding:6px; }
</style>
</head>
<body>

<div class="toolbar">
  <h1>üß† Whiteboard</h1>
  <!-- Always-visible: small status + open modal button -->
  <button id="openConn" style="margin-left:8px;">Connect</button>
  <div id="connectBtn" class="connect-indicator disconnected">Not connected</div>
</div>

<div class="leftpane">
  <h3>Tools</h3>
  <div style="display:flex; gap:6px;">
    <button id="penTool" class="icon">‚úèÔ∏è</button>
    <button id="eraserTool" class="icon">üßΩ</button>
  </div>
  <label class="smalltxt">Brush size</label>
  <input id="penSize" type="range" min="1" max="30" value="3" />
  <button id="undoBtn">Undo</button>
  <button id="addPageBtn">Add Page</button>
  <button id="downloadBtn">Download PDF</button>

  <hr/>

  <h3>Palette</h3>
  <div class="color-table" id="colorTable"></div>
  <h3>Background</h3>
  <div class="bg-table" id="bgTable"></div>

  <div class="smalltxt">Saved key: <span id="savedKey">‚Äî</span></div>
</div>

<div class="page-tabs" id="pageTabs"></div>

<div class="canvas-wrap">
  <canvas id="canvas"></canvas>
</div>

<!-- Connection Modal (all connection UI inside) -->
<div id="connModal" class="modal" aria-hidden="true">
  <div class="modal-content">
    <button class="close" id="closeModal">&times;</button>
    <h2>Connection ‚Äî Host / Client</h2>
    <p class="small">Use Host on the drawing machine and share the Offer Key with Client(s). Clients are view-only.</p>

    <div class="side-by-side" style="margin-top:10px;">
      <div class="section">
        <h3>Host</h3>
        <button id="hostBtn">Start as Host</button>
        <div class="small">Offer Key (copy & share):</div>
        <textarea id="offerKeyOut" readonly placeholder="Offer key will appear here"></textarea>
        <button id="manualDelOffer">Delete Offer Key (debug)</button>
        <hr/>
        <button id="syncNowBtn" class="hidden">Sync Now (force)</button>
        <div class="small">Auto-sync will push updates periodically when a client is connected.</div>
      </div>

      <div class="section">
        <h3>Client</h3>
        <div class="small">Enter Host's Offer Key:</div>
        <input id="offerKeyIn" placeholder="Enter offer key" />
        <button id="clientBtn">Join as Client</button>
        <div class="small">Answer Key (published):</div>
        <textarea id="answerKeyOut" readonly placeholder="Answer key (auto)"></textarea>
        <button id="manualDelAnswer">Delete Answer Key (debug)</button>
        <hr/>
        <h4>Manual (fallback)</h4>
        <div class="small">Paste Offer JSON (manual flow)</div>
        <textarea id="manualOfferIn" placeholder='{"type":"offer","sdp":"..."}'></textarea>
        <button id="manualCreateAnswer">Create Answer (manual)</button>
        <div class="small">Paste Answer JSON (manual)</div>
        <textarea id="manualAnswerIn" placeholder='{"type":"answer","sdp":"..."}'></textarea>
        <button id="manualSetAnswer">Set Answer</button>
      </div>
    </div>

    <hr/>
    <h3>Save / Load board</h3>
    <div style="display:flex; gap:8px;">
      <button id="saveBtn">Save to Backend</button>
      <button id="loadBtn">Load from Backend</button>
    </div>
    <div class="small">Saved key: <span id="savedKeyModal">‚Äî</span></div>

    <hr/>
    <h3>Logs</h3>
    <textarea id="logArea" readonly placeholder="Event log..."></textarea>
  </div>
</div>

<script>
/* ========== Configuration ========== */
const BACKEND = "https://script.google.com/macros/s/AKfycbwV7UQPANkrhRThtqhc7QS9-ev0DGJEgfbyphs42SThyPqQ5riTGtzYRO4pH6xD-OuWNQ/exec";
const CHUNK_SIZE = 12000; // safe chunk size for datachannel

/* ========== Short helpers ========== */
const $ = id => document.getElementById(id);
function log(msg){ const area=$('logArea'); const t=(new Date()).toLocaleTimeString(); area.value = `${t} - ${msg}\n` + area.value; console.log('[WB]', msg); }
function setText(id, t){ const e=$(id); if(e) e.textContent = t; }
async function db_set(obj){ const url = BACKEND + '?action=set&json=' + encodeURIComponent(JSON.stringify(obj)); const r = await fetch(url); return r.json(); }
async function db_get_keys(keys){ const url = BACKEND + '?action=get&keys=' + encodeURIComponent(keys); const r = await fetch(url); return r.json(); }
async function db_get_all(){ const r = await fetch(BACKEND); return r.json(); }
async function db_delete(key){ try{ await fetch(BACKEND + '?action=delete&key=' + encodeURIComponent(key)); }catch(e){ /* ignore */ } }
function extractKeyFromSetResponse(res){
  if(!res) return null;
  if(typeof res.key === 'string') return res.key;
  for(const k of ['id','result','Id']) if(typeof res[k] === 'string') return res[k];
  for(const p in res) if(typeof res[p] === 'string') return res[p];
  return null;
}

/* ========== Whiteboard state & UI ========== */
/* canvas setup */
const canvas = $('canvas'), ctx = canvas.getContext('2d');
let dpr = window.devicePixelRatio || 1;
let pages = [{ history: [] }], currentPage = 0;
let penColor = '#fff', bgColor = '#000', penSize = 3, isEraser = false;
let allowDrawing = true;
function fitCanvas(){ const rect = canvas.getBoundingClientRect(); dpr = window.devicePixelRatio || 1; canvas.width = Math.round(rect.width * dpr); canvas.height = Math.round(rect.height * dpr); ctx.setTransform(dpr,0,0,dpr,0,0); redraw(); }
window.addEventListener('resize', fitCanvas); setTimeout(fitCanvas,50);
function ensureInitialHistory(){ const pg = pages[currentPage]; if(!pg.history || pg.history.length===0){ ctx.save(); ctx.fillStyle = bgColor; ctx.fillRect(0,0,canvas.width/dpr,canvas.height/dpr); ctx.restore(); pg.history = pg.history || []; pg.history.push(canvas.toDataURL('image/png')); } }
ensureInitialHistory();
function pushHistory(){ const pg = pages[currentPage]; pg.history = pg.history || []; pg.history.push(canvas.toDataURL('image/png')); if(pg.history.length > 50) pg.history.shift(); }
function redraw(){ ctx.save(); ctx.fillStyle = bgColor; ctx.fillRect(0,0,canvas.width/dpr,canvas.height/dpr); ctx.restore(); const pg = pages[currentPage]; if(pg && pg.history && pg.history.length){ const img = new Image(); img.onload = ()=> ctx.drawImage(img,0,0,canvas.width/dpr,canvas.height/dpr); img.src = pg.history[pg.history.length-1]; } }
let drawing=false;
function getPointer(e){ const r = canvas.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
canvas.addEventListener('pointerdown', e=>{ if(!allowDrawing) return; drawing=true; canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId); const p=getPointer(e); ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.strokeStyle = isEraser?bgColor:penColor; ctx.lineWidth=penSize; ctx.lineJoin=ctx.lineCap='round'; });
canvas.addEventListener('pointermove', e=>{ if(!drawing || !allowDrawing) return; const p=getPointer(e); ctx.lineTo(p.x,p.y); ctx.stroke(); });
function endStroke(){ if(!drawing || !allowDrawing) return; drawing=false; ctx.closePath(); pushHistory(); }
canvas.addEventListener('pointerup', endStroke); canvas.addEventListener('pointercancel', endStroke);

/* UI controls */
$('penTool').onclick = ()=> isEraser=false;
$('eraserTool').onclick = ()=> isEraser=true;
$('penSize').oninput = ()=> penSize = parseInt($('penSize').value);
$('undoBtn').onclick = ()=> { if(!allowDrawing) return; const pg = pages[currentPage]; if(pg.history && pg.history.length>1){ pg.history.pop(); redraw(); } };
$('addPageBtn').onclick = ()=> { if(!allowDrawing) return; pages.push({history:[]}); currentPage = pages.length-1; updateTabs(); ensureInitialHistory(); redraw(); };
$('downloadBtn').onclick = async ()=> { const js = await import('https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js'); const { jsPDF } = js; const pdf = new jsPDF.jsPDF(); pages.forEach((p,i)=>{ if(i>0) pdf.addPage(); const img = p.history && p.history.length ? p.history[p.history.length-1] : canvas.toDataURL('image/png'); pdf.addImage(img,'PNG',0,0,210,297); }); pdf.save('whiteboard.pdf'); };

/* palettes & tabs */
function updateTabs(){ const tabs=$('pageTabs'); tabs.innerHTML=''; pages.forEach((_,i)=>{ const b=document.createElement('button'); b.textContent=`Page ${i+1}`; if(i===currentPage) b.classList.add('active'); b.onclick=()=>{ currentPage=i; updateTabs(); redraw(); }; tabs.appendChild(b); }); }
updateTabs();
['#fff','#f00','#0f0','#00f','#ff0','#0ff','#f0f','#888'].forEach(c=>{ const d=document.createElement('div'); d.style.background=c; d.onclick=()=> penColor=c; $('colorTable').appendChild(d); });
['#000','#111','#222','#333'].forEach(c=>{ const d=document.createElement('div'); d.style.background=c; d.onclick=()=>{ bgColor=c; redraw(); }; $('bgTable').appendChild(d); });

/* ========== Connection modal behaviour ========== */
$('openConn').onclick = ()=>{ $('connModal').style.display='block'; $('connModal').setAttribute('aria-hidden','false'); };
$('closeModal').onclick = ()=>{ $('connModal').style.display='none'; $('connModal').setAttribute('aria-hidden','true'); };
window.onclick = e => { if(e.target === $('connModal')){ $('connModal').style.display='none'; $('connModal').setAttribute('aria-hidden','true'); } };

/* ========== Network / WebRTC + DB signaling (with chunking & heartbeat) ========== */
let pc = null, dataChannel = null;
let hostOfferKey = null, clientAnswerKey = null, foundAnswerKey = null;
let pollInterval = null;

/* connection indicator update */
function setConnectState(ok){ const b=$('connectBtn'); b.classList.toggle('connected', ok); b.classList.toggle('disconnected', !ok); b.textContent = ok ? 'Connected' : 'Not connected'; }
setInterval(()=>{ if(!pc) { setConnectState(false); return; } setConnectState(pc.connectionState === 'connected'); }, 2000);

/* chunking and heartbeat */
let recvBuffer = null, recvTotal = 0;
let heartbeatTimer = null;
function startHeartbeat(){ stopHeartbeat(); heartbeatTimer = setInterval(()=>{ try{ if(dataChannel && dataChannel.readyState==='open') dataChannel.send(JSON.stringify({__hb:1})); }catch(e){} }, 5000); }
function stopHeartbeat(){ if(heartbeatTimer){ clearInterval(heartbeatTimer); heartbeatTimer=null; } }

/* wait for ICE candidates gathering */
function waitForIce(pcRef, timeout=5000){ return new Promise(resolve=>{ if(!pcRef) resolve(); if(pcRef.iceGatheringState === 'complete') resolve(); function h(){ if(pcRef.iceGatheringState==='complete'){ pcRef.removeEventListener('icegatheringstatechange', h); resolve(); } } pcRef.addEventListener('icegatheringstatechange', h); setTimeout(resolve, timeout); }); }

/* create peer */
function createPeer(){
  pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
  pc.onconnectionstatechange = ()=>{ log('PC state: '+pc.connectionState); if(pc.connectionState === 'connected'){ // cleanup keys
      if(hostOfferKey){ db_delete(hostOfferKey); hostOfferKey=null; }
      if(clientAnswerKey){ db_delete(clientAnswerKey); clientAnswerKey=null; }
      if(foundAnswerKey){ db_delete(foundAnswerKey); foundAnswerKey=null; }
    }
  };
}

/* data channel message handler with chunk reassembly */
function handleIncoming(raw){
  let obj;
  try{ obj = JSON.parse(raw); }catch(e){ return; }
  if(obj.__hb) return; // heartbeat
  if(obj.__type === 'begin'){ recvBuffer = new Array(obj.total); recvTotal = obj.total; return; }
  if(obj.__type === 'chunk'){ if(recvBuffer) recvBuffer[obj.index] = obj.data; return; }
  if(obj.__type === 'end'){
    const full = (recvBuffer||[]).join('');
    recvBuffer = null; recvTotal = 0;
    try{ const parsed = JSON.parse(full); applyRemote(parsed); } catch(e){ console.warn('failed apply remote', e); }
    return;
  }
  // small message (fallback)
  if(obj.type === 'smallSync'){ applyRemote(obj.data); return; }
}

/* send chunked */
function sendLarge(label, text){
  if(!dataChannel || dataChannel.readyState !== 'open') throw new Error('DC not open');
  const total = Math.ceil(text.length / CHUNK_SIZE);
  dataChannel.send(JSON.stringify({ __type:'begin', label, total }));
  for(let i=0;i<total;i++){
    const chunk = text.slice(i*CHUNK_SIZE, (i+1)*CHUNK_SIZE);
    dataChannel.send(JSON.stringify({ __type:'chunk', index:i, data:chunk }));
  }
  dataChannel.send(JSON.stringify({ __type:'end', label }));
}
/* safe send: small if fits else chunk */
function sendSafe(p){
  const json = JSON.stringify(p);
  if(json.length < CHUNK_SIZE) { dataChannel.send(JSON.stringify({ type:'smallSync', data: p })); }
  else sendLarge('canvasSync', json);
}

/* Apply remote on clients */
function applyRemote(obj){
  if(!obj) return;
  if(obj.pages) { pages = obj.pages; currentPage = obj.currentPage || 0; updateTabs(); }
  if(obj.currentImage){
    const img = new Image();
    img.onload = ()=> { ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr); ctx.drawImage(img,0,0,canvas.width/dpr,canvas.height/dpr); };
    img.src = obj.currentImage;
  }
}

/* Host flow */
$('hostBtn').onclick = async ()=>{
  try{
    allowDrawing = true; $('syncNowBtn').classList.remove('hidden');
    createPeer();

    // create reliable ordered channel
    dataChannel = pc.createDataChannel('board', { ordered: true });
    dataChannel.onopen = ()=>{ log('DC open (host)'); startHeartbeat(); startAutoSync(); };
    dataChannel.onclose = ()=>{ log('DC close (host)'); stopHeartbeat(); stopAutoSync(); };
    dataChannel.onmessage = (ev)=> handleIncoming(ev.data);

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    await waitForIce(pc);

    const res = await db_set({ offer: pc.localDescription });
    const key = extractKeyFromSetResponse(res);
    if(!key) throw new Error('No key returned by backend');
    hostOfferKey = String(key);
    $('offerKeyOut').value = hostOfferKey;
    log('Offer published: ' + hostOfferKey);

    // poll DB for answers targeting this offer key
    let attempts = 0;
    pollInterval = setInterval(async ()=>{
      attempts++; if(attempts>120){ clearInterval(pollInterval); pollInterval=null; log('Timed out waiting for answer'); return; }
      try{
        const all = await db_get_all();
        for(const k in all){
          const raw = all[k]; if(!raw) continue;
          let parsed; try{ parsed = JSON.parse(raw); }catch(e){ continue; }
          if(parsed && parsed.answer_to === hostOfferKey && parsed.answer){
            foundAnswerKey = k;
            log('Answer found in DB: ' + foundAnswerKey);
            try{
              if(pc.signalingState === 'stable') await pc.setRemoteDescription(parsed.answer);
              else { await new Promise(r=>setTimeout(r,200)); await pc.setRemoteDescription(parsed.answer); }
              clientAnswerKey = foundAnswerKey;
            }catch(e){ console.warn('setRemoteDescription error', e); }
            clearInterval(pollInterval); pollInterval=null;
            return;
          }
        }
      }catch(e){ console.warn('poll error', e); }
    }, 1500);

  }catch(err){ console.error(err); alert('Host error: ' + (err.message||err)); }
};

/* Client flow */
$('clientBtn').onclick = async ()=>{
  try{
    allowDrawing = false; $('syncNowBtn').classList.add('hidden');
    const key = $('offerKeyIn').value.trim() || $('offerKeyInput').value.trim();
    if(!key) return alert('Enter host offer key (in modal or main input)');
    log('Fetching offer: ' + key);
    const got = await db_get_keys(key);
    if(!got || !got[key]) { alert('Offer not found'); return; }
    let parsed = null;
    try { parsed = JSON.parse(got[key]); } catch(e){ alert('Invalid stored JSON'); return; }
    if(!parsed.offer) { alert('No offer field'); return; }

    createPeer();
    pc.ondatachannel = e => {
      dataChannel = e.channel;
      dataChannel.onopen = ()=>{ log('DC open (client)'); startHeartbeat(); };
      dataChannel.onclose = ()=>{ log('DC close (client)'); stopHeartbeat(); };
      dataChannel.onmessage = ev => handleIncoming(ev.data);
    };

    await pc.setRemoteDescription(parsed.offer);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    await waitForIce(pc);

    const res = await db_set({ answer_to: key, answer: pc.localDescription });
    const aKey = extractKeyFromSetResponse(res);
    clientAnswerKey = aKey ? String(aKey) : null;
    $('answerKeyOut').value = clientAnswerKey || '';
    log('Answer published: ' + clientAnswerKey);
  }catch(e){ console.error(e); alert('Client error: ' + (e.message||e)); }
};

/* Manual fallback handlers (set answer, create answer etc) */
$('manualCreateAnswer').onclick = async ()=>{
  try{
    const txt = $('manualOfferIn').value.trim(); if(!txt) return alert('Paste offer JSON');
    const offer = JSON.parse(txt);
    createPeer();
    pc.ondatachannel = e=>{ dataChannel = e.channel; dataChannel.onmessage = ev=> handleIncoming(ev.data); dataChannel.onopen = ()=> startHeartbeat(); dataChannel.onclose = ()=> stopHeartbeat(); };
    await pc.setRemoteDescription(offer);
    const ans = await pc.createAnswer();
    await pc.setLocalDescription(ans);
    $('manualAnswerIn').value = JSON.stringify(pc.localDescription);
    log('Manual answer created in text area');
  }catch(e){ alert('Manual create answer failed'); console.error(e); }
};
$('manualSetAnswer').onclick = async ()=>{ try{ const txt = $('manualAnswerIn').value.trim(); if(!txt) return alert('Paste answer JSON'); const ans = JSON.parse(txt); if(!pc) return alert('No PC created'); await pc.setRemoteDescription(ans); log('Manual answer set'); }catch(e){ alert('Set answer failed'); console.error(e); } };

/* sync now button */
$('syncNowBtn').onclick = ()=>{ if(!dataChannel || dataChannel.readyState !== 'open') return alert('No connected client'); const payload = { pages, currentPage, currentImage: canvas.toDataURL('image/png') }; try{ sendSafe(payload); log('Forced sync sent'); }catch(e){ alert('Sync failed'); } };

/* start/stop auto-sync for host */
let autoSyncTimer = null;
function startAutoSync(){ if(autoSyncTimer) clearInterval(autoSyncTimer); autoSyncTimer = setInterval(()=>{ if(dataChannel && dataChannel.readyState==='open'){ try{ sendSafe({ pages, currentPage, currentImage: canvas.toDataURL('image/png') }); }catch(e){ console.warn('autosync send failed', e); } } }, 1000); }
function stopAutoSync(){ if(autoSyncTimer) clearInterval(autoSyncTimer); autoSyncTimer=null; }

/* sendSafe wrapper */
function sendSafe(obj){ const j = JSON.stringify(obj); if(j.length < CHUNK_SIZE){ dataChannel.send(JSON.stringify({ type:'smallSync', data: obj })); } else { sendLarge('canvasSync', j); } }

/* ========== Chunked send/receive functions ========== */
function sendLarge(label, text){
  if(!dataChannel || dataChannel.readyState !== 'open') throw new Error('DC not open');
  const total = Math.ceil(text.length / CHUNK_SIZE);
  dataChannel.send(JSON.stringify({ __type:'begin', label, total }));
  for(let i=0;i<total;i++){
    const chunk = text.slice(i*CHUNK_SIZE, (i+1)*CHUNK_SIZE);
    dataChannel.send(JSON.stringify({ __type:'chunk', index:i, data:chunk }));
  }
  dataChannel.send(JSON.stringify({ __type:'end', label }));
}

/* handle manual delete (debug) */
$('manualDelOffer').onclick = async ()=>{ if(!hostOfferKey) return alert('No host key'); await db_delete(hostOfferKey); log('Offer deleted: ' + hostOfferKey); hostOfferKey=null; $('offerKeyOut').value=''; };
$('manualDelAnswer').onclick = async ()=>{ if(!clientAnswerKey) return alert('No answer key'); await db_delete(clientAnswerKey); log('Answer deleted: ' + clientAnswerKey); clientAnswerKey=null; $('answerKeyOut').value=''; };

/* ========== Save / Load board to backend ========== */
$('saveBtn').onclick = async ()=>{
  try{
    const payload = { saved: { pages, currentPage, ts: Date.now() } };
    const res = await db_set(payload);
    const key = extractKeyFromSetResponse(res);
    if(!key) return alert('Save failed');
    setText('savedKey', key); setText('savedKeyModal', key); $('offerKeyInput').value = key; alert('Saved key: ' + key);
  }catch(e){ console.error(e); alert('Save failed'); }
};
$('loadBtn').onclick = async ()=>{
  const key = prompt('Enter save key:'); if(!key) return;
  try{
    const got = await db_get_keys(key);
    if(!got || !got[key]) return alert('Not found');
    const parsed = JSON.parse(got[key]);
    if(!parsed.saved) return alert('Invalid saved record');
    pages = parsed.saved.pages || pages;
    currentPage = parsed.saved.currentPage || 0;
    updateTabs(); redraw(); alert('Loaded');
  }catch(e){ console.error(e); alert('Load failed'); }
};

/* ========== Utils ========== */
function log(str){ const area = $('logArea'); area.value = (new Date()).toLocaleTimeString() + ' ‚Äî ' + str + '\n' + area.value; console.log(str); }
function setText(id,val){ const el=$(id); if(el) el.textContent=val; }

/* init */
(function init(){ ensureInitialHistory(); updateTabs(); })();

</script>
</body>
</html>
